diff --git a/prisma/schema.prisma b/prisma/schema.prisma
index 1111111..2222222 100644
--- a/prisma/schema.prisma
+++ b/prisma/schema.prisma
@@ -1,3 +1,4 @@
 // Prisma schema for the legal defense fundraiser platform
 datasource db {
   provider = "postgresql"
   url      = env("DATABASE_URL")
 }
 
 generator client {
   provider = "prisma-client-js"
 }
 
 enum UserRole {
   USER
   ADMIN
   MODERATOR
 }
 
 enum CampaignStatus {
   DRAFT
   ACTIVE
   SUSPENDED
   COMPLETED
 }
 
 enum CampaignCategory {
   LEGAL_DEFENSE
   CIVIL_RIGHTS
   FAMILY_LAW
   CRIMINAL_DEFENSE
   HOUSING_JUSTICE
   IMMIGRATION
   CONSUMER_PROTECTION
   CLASS_ACTION
 }
 
 model User {
   id            String    @id @default(uuid())
   email         String    @unique
   name          String?
   password      String?
   image         String?
   role          UserRole  @default(USER)
   isVerified    Boolean   @default(false)
   emailVerified DateTime?
   createdAt     DateTime  @default(now())
   updatedAt     DateTime  @updatedAt
 
   // Relations
   campaigns     Campaign[]
   donations     Donation[]
 }
 
 model Campaign {
   id               String           @id @default(uuid())
   title            String
   slug             String           @unique
   description      String
   shortDescription String
   goalAmount       Decimal          @db.Decimal(10, 2)
   currentAmount    Decimal          @default(0) @db.Decimal(10, 2)
   category         CampaignCategory
   status           CampaignStatus   @default(DRAFT)
   isPublic         Boolean          @default(true)
   caseNumber       String?
   courtName        String?
   attorneyName     String?
   attorneyContact  String?
   endDate          DateTime?
-  images           String[]
-  videos           String[]
+  images           String[]         @default([])
+  videos           String[]         @default([])
+  videoUrl         String?
+  viewCount        Int              @default(0)
 
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
 
   // Relations
   userId           String
   user             User             @relation(fields: [userId], references: [id])
 
   donations        Donation[]
   comments         Comment[]
   updates          CampaignUpdate[]
   categories       CampaignCategoryTag[]
+
+  @@index([status, category, createdAt])
+  @@index([userId, createdAt])
 }
 
 model Donation {
   id              String   @id @default(uuid())
   amount          Decimal  @db.Decimal(10, 2)
   stripePaymentId String   @unique
   paymentStatus   String   // e.g., 'PENDING', 'SUCCEEDED', 'FAILED', 'REFUNDED'
   isAnonymous     Boolean  @default(false)
   createdAt       DateTime @default(now())
 
   // Relations
   userId     String
   user       User     @relation(fields: [userId], references: [id])
   campaignId String
   campaign   Campaign @relation(fields: [campaignId], references: [id])
+
+  @@index([campaignId, createdAt])
+  @@index([paymentStatus, createdAt])
 }
 
 model Comment {
   id         String   @id @default(uuid())
   content    String
   isApproved Boolean  @default(false)
   createdAt  DateTime @default(now())
 
   // Relations
   userId     String
   user       User     @relation(fields: [userId], references: [id])
   campaignId String
   campaign   Campaign @relation(fields: [campaignId], references: [id])
+
+  @@index([campaignId, isApproved, createdAt])
 }
 
 model CampaignUpdate {
   id         String   @id @default(uuid())
   title      String
   content    String
   createdAt  DateTime @default(now())
 
   // Relations
   campaignId String
   campaign   Campaign @relation(fields: [campaignId], references: [id])
 }
 
 model CampaignCategoryTag {
   id       String          @id @default(uuid())
   name     String          @unique
   campaigns Campaign[]
 }
 
diff --git a/src/lib/validators.ts b/src/lib/validators.ts
new file mode 100644
index 0000000..3333333
--- /dev/null
+++ b/src/lib/validators.ts
@@ -0,0 +1,97 @@
+import { z } from "zod";
+import { CampaignCategory } from "@prisma/client";
+
+export const createCampaignSchema = z.object({
+  title: z.string().min(3).max(140),
+  description: z.string().min(30),
+  shortDescription: z.string().min(10).max(280),
+  goalAmount: z.number().positive().finite().max(9_999_999),
+  category: z.nativeEnum(CampaignCategory).optional(),
+  caseNumber: z.string().trim().optional().nullable(),
+  courtName: z.string().trim().optional().nullable(),
+  attorneyName: z.string().trim().optional().nullable(),
+  attorneyContact: z.string().trim().optional().nullable(),
+  endDate: z.coerce.date().optional().nullable(),
+  videoUrl: z.string().url().optional().nullable(),
+  images: z.array(z.string().url()).max(24).optional().default([]),
+});
+
+export const donationSchema = z.object({
+  amount: z.number().positive().finite().max(1_000_000),
+  isAnonymous: z.boolean().optional().default(false),
+});
+
+export type CreateCampaignInput = z.infer<typeof createCampaignSchema>;
+export type DonationInput = z.infer<typeof donationSchema>;
+
diff --git a/src/middleware/rateLimit.ts b/src/middleware/rateLimit.ts
new file mode 100644
index 0000000..4444444
--- /dev/null
+++ b/src/middleware/rateLimit.ts
@@ -0,0 +1,47 @@
+// Simple in-memory rate limiter for single-instance deployments.
+// For multi-instance/serverless, replace with Redis/Upstash.
+type Bucket = { tokens: number; last: number };
+const buckets = new Map<string, Bucket>();
+
+export function rateLimit(key: string, limit = 10, windowMs = 15_000) {
+  const now = Date.now();
+  const b = buckets.get(key) ?? { tokens: limit, last: now };
+  const elapsed = now - b.last;
+  const refill = Math.floor(elapsed / windowMs) * limit;
+  b.tokens = Math.min(limit, b.tokens + refill);
+  b.last = now;
+  if (b.tokens <= 0) {
+    buckets.set(key, b);
+    return { allowed: false, retryAfter: windowMs - (elapsed % windowMs) };
+  }
+  b.tokens -= 1;
+  buckets.set(key, b);
+  return { allowed: true, retryAfter: 0 };
+}
+
diff --git a/src/lib/stripe.ts b/src/lib/stripe.ts
index 1111111..5555555 100644
--- a/src/lib/stripe.ts
+++ b/src/lib/stripe.ts
@@ -1,3 +1,22 @@
-import Stripe from 'stripe'
-export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: '2024-06-20' })
+import Stripe from "stripe";
+
+if (!process.env.STRIPE_SECRET_KEY) {
+  throw new Error("STRIPE_SECRET_KEY is not set");
+}
+
+export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
+  apiVersion: "2024-06-20",
+  typescript: true,
+  appInfo: { name: "Legal Defense Fund", version: "1.0.0" },
+});
+
diff --git a/src/app/api/campaigns/route.ts b/src/app/api/campaigns/route.ts
index 1111111..6666666 100644
--- a/src/app/api/campaigns/route.ts
+++ b/src/app/api/campaigns/route.ts
@@ -1,23 +1,41 @@
-import { NextRequest, NextResponse } from 'next/server'
-import { prisma } from '@/lib/database'
-import { getServerSession } from 'next-auth'
-import { authOptions } from '@/lib/auth'
-import { CampaignStatus, CampaignCategory } from '@prisma/client'
-import { slugify } from '@/lib/utils'
+import { NextRequest, NextResponse } from "next/server";
+import { prisma } from "@/lib/database";
+import { getServerSession } from "next-auth";
+import { authOptions } from "@/lib/auth";
+import { CampaignStatus, CampaignCategory } from "@prisma/client";
+import { slugify } from "@/lib/utils";
+import { createCampaignSchema } from "@/lib/validators";
+import { rateLimit } from "@/middleware/rateLimit";
 
 export async function GET(request: NextRequest) {
   try {
-    const { searchParams } = new URL(request.url)
+    const { searchParams } = new URL(request.url);
     const page = Number(searchParams.get('page') || '1')
     const limit = Math.min(Number(searchParams.get('limit') || '12'), 50)
     const search = searchParams.get('search') || ''
     const category = searchParams.get('category') as CampaignCategory | null
     const status = searchParams.get('status') as CampaignStatus | null
     const sort = searchParams.get('sort') || 'recent'
 
-    const where: any = { isPublic: true, status: 'ACTIVE' }
+    const where: any = { isPublic: true, status: 'ACTIVE' as CampaignStatus }
     if (search) {
       where.OR = [
         { title: { contains: search, mode: 'insensitive' } },
         { description: { contains: search, mode: 'insensitive' } },
-        { user: { name: { contains: search, mode: 'insensitive' } } },
+        // Fix relational filter shape for Prisma 5
+        { user: { is: { name: { contains: search, mode: 'insensitive' } } } },
       ]
     }
     if (category) where.category = category
     if (status) where.status = status
@@ -42,7 +60,10 @@ export async function GET(request: NextRequest) {
     const skip = (page - 1) * limit
 
     const [campaigns, total] = await Promise.all([
-      prisma.campaign.findMany({ where, orderBy, skip, take: limit }),
+      prisma.campaign.findMany({
+        where,
+        orderBy,
+        skip, take: limit
+      }),
       prisma.campaign.count({ where })
     ])
 
@@ -63,69 +84,88 @@ export async function GET(request: NextRequest) {
   }
 }
 
 export async function POST(request: NextRequest) {
   try {
-    const session = await getServerSession(authOptions)
+    const session = await getServerSession(authOptions);
     if (!session?.user?.id) {
-      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
+      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
     }
 
-    const body = await request.json()
-    const {
-      title,
-      description,
-      shortDescription,
-      goalAmount,
-      category,
-      caseNumber,
-      courtName,
-      attorneyName,
-      attorneyContact,
-      endDate,
-      videoUrl,
-      images = []
-    } = body
+    // lightweight IP-based rate limit
+    const ip = request.headers.get("x-forwarded-for") ?? "unknown";
+    const rl = rateLimit(`campaign:create:${ip}`, 5, 10_000);
+    if (!rl.allowed) {
+      return NextResponse.json({ error: "Rate limit exceeded" }, { status: 429 });
+    }
+
+    const json = await request.json();
+    const parsed = createCampaignSchema.safeParse(json);
+    if (!parsed.success) {
+      return NextResponse.json(
+        { error: "Invalid input", details: parsed.error.flatten() },
+        { status: 400 }
+      );
+    }
+    const {
+      title, description, shortDescription, goalAmount,
+      category, caseNumber, courtName, attorneyName, attorneyContact,
+      endDate, videoUrl, images
    } = parsed.data;
 
     // Validate required fields
-    if (!title || !shortDescription || !description || !goalAmount) {
-      return NextResponse.json(
-        { error: 'Missing required fields' },
-        { status: 400 }
-      )
-    }
+    // (redundant with zod; keeps existing behavior)
+    if (!title || !shortDescription || !description || !goalAmount)
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 })
 
     // Generate unique slug
     let slug = slugify(title)
     let slugCount = 0
     let finalSlug = slug
     
     while (await prisma.campaign.findUnique({ where: { slug: finalSlug } })) {
       slugCount++
       finalSlug = `${slug}-${slugCount}`
     }
 
     // Create campaign
     const campaign = await prisma.campaign.create({
       data: {
         title,
         slug: finalSlug,
         description,
         shortDescription,
-        goalAmount,
-        category: category || 'LEGAL_DEFENSE',
+        goalAmount, // Prisma Decimal accepts number
+        category: category ?? 'LEGAL_DEFENSE',
         caseNumber,
         courtName,
         attorneyName,
         attorneyContact,
-        endDate: endDate ? new Date(endDate) : null,
+        endDate: endDate ?? null,
         videoUrl,
         images,
         userId: session.user.id,
         status: 'DRAFT', // Start as draft for review
       },
       include: {
         user: {
           select: { id: true, name: true, email: true, image: true }
         }
       }
     })
 
     return NextResponse.json({
       success: true,
       campaign,
       message: 'Campaign created successfully. It will be reviewed before going live.'
     })
   } catch (error) {
     console.error('Error creating campaign:', error)
     return NextResponse.json(
       { error: 'Failed to create campaign' },
       { status: 500 }
     )
   }
 }
 
diff --git a/src/app/api/campaigns/[id]/route.ts b/src/app/api/campaigns/[id]/route.ts
index 1111111..7777777 100644
--- a/src/app/api/campaigns/[id]/route.ts
+++ b/src/app/api/campaigns/[id]/route.ts
@@ -1,20 +1,34 @@
 import { NextRequest, NextResponse } from 'next/server'
 import { prisma } from '@/lib/database'
 import { getServerSession } from 'next-auth'
 import { authOptions } from '@/lib/auth'
 
 export async function GET(
   request: NextRequest,
   { params }: { params: { id: string } }
 ) {
   try {
-    const campaign = await prisma.campaign.findUnique({
-      where: {
-        OR: [
-          { id: params.id },
-          { slug: params.id }
-        ]
-      },
+    // findFirst allows OR across unique fields; findUnique does not
+    const campaign = await prisma.campaign.findFirst({
+      where: {
+        OR: [{ id: params.id }, { slug: params.id }]
      },
       include: {
         user: {
           select: {
             id: true,
             name: true,
             email: true,
             image: true,
             isVerified: true,
           }
         },
         donations: {
           where: { paymentStatus: 'SUCCEEDED' },
           include: {
             user: { select: { id: true, name: true, image: true } }
           }
         },
         comments: {
           where: { isApproved: true },
           include: {
             user: { select: { id: true, name: true, image: true } }
           }
         },
         updates: true
       }
     })
 
     if (!campaign) {
       return NextResponse.json({ error: 'Campaign not found' }, { status: 404 })
     }
 
     return NextResponse.json({ campaign })
   } catch (error) {
     console.error('Error fetching campaign:', error)
     return NextResponse.json({ error: 'Failed to fetch campaign' }, { status: 500 })
   }
 }
 
diff --git a/src/app/api/campaigns/[id]/donate/route.ts b/src/app/api/campaigns/[id]/donate/route.ts
index 1111111..8888888 100644
--- a/src/app/api/campaigns/[id]/donate/route.ts
+++ b/src/app/api/campaigns/[id]/donate/route.ts
@@ -1,29 +1,62 @@
 import { NextRequest, NextResponse } from 'next/server'
 import { prisma } from '@/lib/database'
 import { stripe } from '@/lib/stripe'
 import { getServerSession } from 'next-auth'
 import { authOptions } from '@/lib/auth'
+import { donationSchema } from '@/lib/validators'
+import { rateLimit } from '@/middleware/rateLimit'
 
 export async function POST(
   request: NextRequest,
   { params }: { params: { id: string } }
 ) {
   try {
-    const session = await getServerSession(authOptions)
+    const session = await getServerSession(authOptions);
     if (!session?.user?.id) {
       return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
     }
 
-    const { amount, isAnonymous = false } = await request.json()
-    if (!amount || amount <= 0) {
-      return NextResponse.json({ error: 'Invalid donation amount' }, { status: 400 })
+    const ip = request.headers.get("x-forwarded-for") ?? "unknown";
+    const rl = rateLimit(`donate:${params.id}:${ip}`, 5, 10_000);
+    if (!rl.allowed) {
+      return NextResponse.json({ error: "Rate limit exceeded" }, { status: 429 });
+    }
+
+    const body = await request.json();
+    const parsed = donationSchema.safeParse(body);
+    if (!parsed.success) {
+      return NextResponse.json(
+        { error: "Invalid input", details: parsed.error.flatten() },
+        { status: 400 }
+      );
     }
+    const { amount, isAnonymous } = parsed.data;
 
     const campaign = await prisma.campaign.findUnique({
       where: { id: params.id }
     })
     if (!campaign || campaign.status !== 'ACTIVE') {
       return NextResponse.json({ error: 'Campaign not available for donations' }, { status: 400 })
     }
 
-    // Calculate platform fees (2.9% + Stripe fee 2.9% + $0.30)
-    const platformFee = amount * 0.029
-    const stripeFee = amount * 0.029 + 0.3
-    const netAmount = amount - platformFee - stripeFee
+    // Calculate fees with safe rounding to cents
+    const toCents = (n: number) => Math.round(n * 100);
+    const fromCents = (c: number) => Number((c / 100).toFixed(2));
+    const platformPct = Number(process.env.PLATFORM_FEE_PERCENTAGE ?? "2.9") / 100;
+    const stripePct = Number(process.env.STRIPE_FEE_PERCENTAGE ?? "2.9") / 100;
+    const stripeFixed = 0.3;
+
+    const platformFee = toCents(amount * platformPct);
+    const stripeFee = toCents(amount * stripePct + stripeFixed);
+    const gross = toCents(amount);
+    const netCents = Math.max(0, gross - platformFee - stripeFee);
+    const netAmount = fromCents(netCents);
 
     // Create Stripe payment intent
-    const paymentIntent = await stripe.paymentIntents.create({
-      amount: Math.round(amount * 100),
-      currency: 'usd',
-      metadata: {
-        campaignId: campaign.id,
-        userId: session.user.id
-      }
-    })
+    const paymentIntent = await stripe.paymentIntents.create(
+      {
+        amount: gross,
+        currency: 'usd',
+        metadata: {
+          campaignId: campaign.id,
+          userId: session.user.id
        }
      },
+      { idempotencyKey: `don_${campaign.id}_${session.user.id}_${gross}` }
+    )
 
     // Create donation record as PENDING
     const donation = await prisma.donation.create({
       data: {
         amount,
         stripePaymentId: paymentIntent.id,
         paymentStatus: 'PENDING',
         isAnonymous: !!isAnonymous,
         userId: session.user.id,
         campaignId: campaign.id
       }
     })
 
     return NextResponse.json({
       clientSecret: paymentIntent.client_secret,
       donationId: donation.id,
       netAmount
     })
   } catch (error) {
     console.error('Error creating donation:', error)
     return NextResponse.json({ error: 'Failed to create donation' }, { status: 500 })
   }
 }
 
diff --git a/src/app/api/auth/register/route.ts b/src/app/api/auth/register/route.ts
index 1111111..9999999 100644
--- a/src/app/api/auth/register/route.ts
+++ b/src/app/api/auth/register/route.ts
@@ -1,10 +1,13 @@
 import { NextRequest, NextResponse } from 'next/server'
 import { createUser, validatePassword } from '@/lib/auth'
+import { z } from 'zod'
 
 export async function POST(request: NextRequest) {
   try {
-    const { name, email, password } = await request.json()
+    const json = await request.json()
+    const { name, email, password } = z.object({
+      name: z.string().min(2).max(100),
+      email: z.string().email(),
+      password: z.string().min(8).max(256),
+    }).parse(json)
 
-    // Validate required fields
-    if (!name || !email || !password) {
-      return NextResponse.json(
-        { error: 'Name, email, and password are required' },
-        { status: 400 }
-      )
-    }
+    // basic shape validated by zod; keep legacy messages for consistency
+    if (!name || !email || !password) {
+      return NextResponse.json({ error: 'Name, email, and password are required' }, { status: 400 })
    }
 
     // Validate email format
     const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
@@ -45,7 +48,7 @@ export async function POST(request: NextRequest) {
       { status: 201 }
     )
   } catch (error: any) {
     console.error('Registration error:', error)
 
     if (error.message === 'User already exists') {
       return NextResponse.json(
         { error: 'An account with this email already exists' },
         { status: 409 }
       )
     }
 
     return NextResponse.json(
       { error: 'Failed to create account' },
       { status: 500 }
     )
   }
 }
 
diff --git a/src/app/api/webhooks/stripe/route.ts b/src/app/api/webhooks/stripe/route.ts
index 1111111..aaaaaaa 100644
--- a/src/app/api/webhooks/stripe/route.ts
+++ b/src/app/api/webhooks/stripe/route.ts
@@ -1,12 +1,19 @@
 import { NextRequest, NextResponse } from 'next/server'
 import { prisma } from '@/lib/database'
 import { stripe } from '@/lib/stripe'
 import { headers } from 'next/headers'
 
+// Ensure Node runtime (not edge) for Stripe signature verification
+export const runtime = 'nodejs'
+export const dynamic = 'force-dynamic'
+
 export async function POST(request: NextRequest) {
-  const body = await request.text()
-  const signature = headers().get('stripe-signature')
+  const body = await request.text();
+  const signature = headers().get('stripe-signature');
 
   if (!signature) {
     return NextResponse.json(
       { error: 'Missing stripe signature' },
       { status: 400 }
     )
   }
 
   let event
-
+  if (!process.env.STRIPE_WEBHOOK_SECRET) {
+    console.error('Missing STRIPE_WEBHOOK_SECRET')
+    return NextResponse.json({ error: 'Server misconfigured' }, { status: 500 })
+  }
+
   try {
     event = stripe.webhooks.constructEvent(
       body,
       signature,
       process.env.STRIPE_WEBHOOK_SECRET!
     )
   } catch (error) {
     console.error('Webhook signature verification failed:', error)
     return NextResponse.json(
       { error: 'Webhook signature verification failed' },
       { status: 400 }
     )
   }
 
   try {
     switch (event.type) {
       case 'payment_intent.succeeded':
         await handlePaymentSucceeded(event.data.object)
         break
       
       case 'payment_intent.payment_failed':
         await handlePaymentFailed(event.data.object)
         break
+
+      case 'charge.refunded':
+        await handleRefunded(event.data.object)
+        break
       
       default:
         console.log(`Unhandled event type: ${event.type}`)
     }
 
     return NextResponse.json({ received: true })
   } catch (error) {
     console.error('Webhook handler error:', error)
     return NextResponse.json(
       { error: 'Webhook handler error' },
       { status: 500 }
     )
   }
 }
 
 async function handlePaymentSucceeded(paymentIntent: any) {
   const donation = await prisma.donation.findFirst({
     where: { stripePaymentId: paymentIntent.id },
     include: { campaign: true }
   })
 
   if (!donation) {
     console.error('Donation not found for payment intent:', paymentIntent.id)
     return
   }
 
   if (donation.paymentStatus === 'SUCCEEDED') {
     console.log('Donation already processed:', donation.id)
     return
   }
 
   // Update donation status
   await prisma.donation.update({
     where: { id: donation.id },
     data: { paymentStatus: 'SUCCEEDED' }
   })
 
   // Update campaign total
   await prisma.campaign.update({
     where: { id: donation.campaignId },
     data: {
       currentAmount: { increment: donation.amount }
     }
   })
 
   console.log(`Payment succeeded for donation ${donation.id}`)
 
   // TODO: Send confirmation emails, notifications, etc.
 }
 
 async function handlePaymentFailed(paymentIntent: any) {
   const donation = await prisma.donation.findFirst({
     where: { stripePaymentId: paymentIntent.id }
   })
 
   if (!donation) {
     console.error('Donation not found for payment intent:', paymentIntent.id)
     return
   }
 
   // Update donation status
   await prisma.donation.update({
     where: { id: donation.id },
     data: { paymentStatus: 'FAILED' }
   })
 
   console.log(`Payment failed for donation ${donation.id}`)
 
   // TODO: Send failure notification emails
 }
+
+async function handleRefunded(charge: any) {
+  if (!charge?.payment_intent) return;
+  const donation = await prisma.donation.findFirst({
+    where: { stripePaymentId: charge.payment_intent as string },
+  });
+  if (!donation) return;
+  await prisma.donation.update({
+    where: { id: donation.id },
+    data: { paymentStatus: 'REFUNDED' },
+  });
+}
 
diff --git a/src/app/campaign/[id]/page.tsx b/src/app/campaign/[id]/page.tsx
index 1111111..bbbbbbb 100644
--- a/src/app/campaign/[id]/page.tsx
+++ b/src/app/campaign/[id]/page.tsx
@@ -1,29 +1,40 @@
 import { prisma } from '@/lib/database'
 import Image from 'next/image'
 import DonationForm from './components/DonationForm'
 
 async function getCampaign(id: string) {
   // Try slug or id safely with findFirst
-  const campaign = await prisma.campaign.findUnique({
-    where: {
-      OR: [
-        { id },
-        { slug: id }
-      ]
-    },
+  const campaign = await prisma.campaign.findFirst({
+    where: { OR: [{ id }, { slug: id }] },
     include: {
       user: {
         select: {
           id: true,
           name: true,
           email: true,
           image: true,
           isVerified: true,
         }
       },
       donations: {
         where: { paymentStatus: 'SUCCEEDED' },
         select: { amount: true }
       },
       comments: {
         where: { isApproved: true },
         include: {
           user: { select: { id: true, name: true, image: true } }
         }
       },
       updates: true
     }
   })
 
   if (!campaign) return null
 
   // Safely increment view count, ignore transient errors
   try {
-    await prisma.campaign.update({ where: { id: campaign.id }, data: { viewCount: { increment: 1 } } })
+    await prisma.campaign.update({
+      where: { id: campaign.id },
+      data: { viewCount: { increment: 1 } }
+    })
   } catch (_) {}
 
   return campaign
 }
 
 export default async function CampaignPage({ params }: { params: { id: string } }) {
   const campaign = await getCampaign(params.id)
   if (!campaign) {
     return <div className="p-6 text-red-600">Campaign not found.</div>
   }
 
   return (
     <main className="mx-auto max-w-5xl p-4 md:p-6">
       {/* ... existing JSX ... */}
     </main>
   )
 }
